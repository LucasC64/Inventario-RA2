{-# LANGUAGE GeneralizedNewtypeDeriving #-}

import Data.Map.Strict (Map)
import qualified Data.Map.Strict as M
import Data.Time (UTCTime, getCurrentTime)
import System.IO (hFlush, stdout)
import System.Directory (doesFileExist)
import Control.Exception (catch, IOException)
import Data.List (sortBy, foldl', groupBy, maximumBy)
import Data.Ord (comparing)
import Data.Char (isSpace)
import Control.Monad (when)

newtype ItemID = ItemID { getID :: String }
  deriving (Show, Read, Eq, Ord)

data Item = Item
  { itemID :: ItemID
  , nome :: String
  , quantidade :: Int
  , categoria :: String
  } deriving (Show, Read, Eq)

data StatusLog = Sucesso | Falha String
  deriving (Show, Read, Eq)

data AcaoLog
  = Add ItemID String Int String
  | Remove ItemID Int
  | Update ItemID Int
  deriving (Show, Read, Eq)

data LogEntry = LogEntry
  { timestamp :: UTCTime
  , acao :: AcaoLog
  , detalhes :: String
  , status :: StatusLog
  } deriving (Show, Read, Eq)

type Inventario = Map ItemID Item
type ResultadoOperacao = (Inventario, LogEntry)

arquivoInv :: FilePath
arquivoInv = "Inventario.dat"

arquivoAuditoria :: FilePath
arquivoAuditoria = "Auditoria.log"

validaQtd :: Int -> Either String Int
validaQtd q = if q < 0 then Left "quantidade invalida" else Right q

validaQtdPos :: Int -> Either String Int
validaQtdPos q = if q <= 0 then Left "quantidade invalida" else Right q

procura :: ItemID -> Inventario -> Either String Item
procura id inv =
  case M.lookup id inv of
    Nothing -> Left "nao achei esse item"
    Just it -> Right it

checaNovo :: ItemID -> Inventario -> Either String ()
checaNovo k inv =
  if M.member k inv then Left "item repetido"
  else Right ()

aplica :: AcaoLog -> Inventario -> Inventario
aplica (Add k n q c) inv = M.insert k (Item k n q c) inv
aplica (Remove k q) inv =
  case M.lookup k inv of
    Nothing -> inv
    Just item ->
      let final = quantidade item - q
      in if final <= 0
         then M.delete k inv
         else M.insert k (item { quantidade = final }) inv
aplica (Update k q) inv =
  case M.lookup k inv of
    Nothing -> M.insert k (Item k "" q "") inv
    Just it -> M.insert k (it { quantidade = q }) inv

addItem :: UTCTime -> ItemID -> String -> Int -> String -> Inventario -> Either String ResultadoOperacao
addItem t k n q c inv = do
  checaNovo k inv
  validaQtd q
  let evt = Add k n q c
  let inv2 = aplica evt inv
  let lg = LogEntry t evt ("add " ++ getID k) Sucesso
  return (inv2, lg)

rmItem :: UTCTime -> ItemID -> Int -> Inventario -> Either String ResultadoOperacao
rmItem t k q inv = do
  validaQtdPos q
  it <- procura k inv
  if quantidade it < q
    then Left "estoque insuficiente"
    else do
      let evt = Remove k q
      let inv2 = aplica evt inv
      let lg = LogEntry t evt ("remove " ++ getID k) Sucesso
      return (inv2, lg)

updItem :: UTCTime -> ItemID -> Int -> Inventario -> Either String ResultadoOperacao
updItem t k q inv = do
  validaQtd q
  _ <- procura k inv
  let evt = Update k q
  let inv2 = aplica evt inv
  let lg = LogEntry t evt ("update " ++ getID k) Sucesso
  return (inv2, lg)

carregaInv :: IO Inventario
carregaInv = do
  ok <- doesFileExist arquivoInv
  if not ok then return M.empty
  else catch (read <$> readFile arquivoInv) (\(_::IOException) -> return M.empty)

carregaLogs :: IO [LogEntry]
carregaLogs = do
  ok <- doesFileExist arquivoAuditoria
  if not ok then return []
  else catch (mapa <$> readFile arquivoAuditoria) (\(_::IOException) -> return [])
  where
    mapa txt = foldl' pegar [] (lines txt)
    pegar acc linha =
      case reads linha of
        [(v, "")] -> v : acc
        _ -> acc

salvaInv :: Inventario -> IO ()
salvaInv inv = writeFile arquivoInv (show inv)

gravaLog :: LogEntry -> IO ()
gravaLog e = appendFile arquivoAuditoria (show e ++ "\n")

falhaLog :: UTCTime -> AcaoLog -> String -> LogEntry
falhaLog t evt msg = LogEntry t evt msg (Falha msg)

parse :: String -> [String]
parse s = reverse (go [] (dropWhile isSpace s))
  where
    go acc [] = acc
    go acc ('"':xs) =
      let (w, r) = span (/= '"') xs
      in go (w:acc) (dropWhile isSpace (drop 1 r))
    go acc xs =
      let (w, r) = break isSpace xs
      in go (w:acc) (dropWhile isSpace r)

execOp :: UTCTime -> Either String ResultadoOperacao -> Inventario -> IO Inventario
execOp _ (Right (inv2, lg)) _ = do
  gravaLog lg
  salvaInv inv2
  putStrLn "ok"
  return inv2

execOp t (Left msg) inv = do
  let dummy = Add (ItemID "") "" 0 ""
  let lg = falhaLog t dummy msg
  gravaLog lg
  putStrLn ("erro: " ++ msg)
  return inv

listar :: Inventario -> IO ()
listar inv =
  let arr = sortBy (comparing itemID) (M.elems inv)
  in mapM_ (\i -> putStrLn (getID (itemID i) ++ " | " ++ nome i ++ " | qtd " ++ show (quantidade i) ++ " | cat " ++ categoria i)) arr

mostrar :: String -> Inventario -> IO ()
mostrar s inv =
  case M.lookup (ItemID s) inv of
    Nothing -> putStrLn "nao achei"
    Just x -> print x

popular :: IO Inventario
popular = do
  t <- getCurrentTime
  logs <- carregaLogs
  let inicial = rebuild logs
  let novos =
        [ItemID ("item" ++ show n) | n <- [1..10], M.notMember (ItemID ("item" ++ show n)) inicial]
  let evs = [Add i ("produto " ++ drop 4 (getID i))
                     (read (drop 4 (getID i)) * 3)
                     ("cat" ++ show (read (drop 4 (getID i)) `mod` 3 + 1))
            | i <- novos ]
  let ents = [LogEntry t e "seed" Sucesso | e <- evs]
  mapM_ gravaLog ents
  logs2 <- carregaLogs
  let novoInv = rebuild logs2
  salvaInv novoInv
  putStrLn "seed ok"
  return novoInv

rebuild :: [LogEntry] -> Inventario
rebuild = foldl' f M.empty
  where
    f inv (LogEntry _ evt _ Sucesso) = aplica evt inv
    f inv _ = inv

agrupa :: Ord a => [a] -> [(a, Int)]
agrupa xs =
  let g = groupBy (==) (sortBy compare xs)
  in map (\h -> (head h, length h)) g

pegaID :: LogEntry -> [ItemID]
pegaID (LogEntry _ evt _ _) =
  case evt of
    Add k _ _ _ -> [k]
    Remove k _ -> [k]
    Update k _ -> [k]

hist :: [LogEntry] -> [String]
hist logs =
  let ids = concatMap pegaID logs
      c = agrupa ids
  in map (\(x,n) -> getID x ++ ": " ++ show n ++ " ops") c

erros :: [LogEntry] -> [LogEntry]
erros = filter (\l -> case status l of Falha _ -> True; _ -> False)

maisMov :: [LogEntry] -> String
maisMov logs =
  let ids = concatMap pegaID logs
  in if null ids then "nenhum"
     else
       let c = agrupa ids
           (k,n) = maximumBy (comparing snd) c
       in getID k ++ " (" ++ show n ++ ")"

relat :: IO ()
relat = do
  logs <- carregaLogs
  putStrLn "\n-- Relatorio --"
  putStrLn "\nItens:"
  mapM_ putStrLn (hist logs)
  putStrLn "\nErros:"
  mapM_ print (erros logs)
  putStrLn "\nMais movimentado:"
  putStrLn (maisMov logs)
  putStrLn ""

processa :: [String] -> Inventario -> IO Inventario
processa cmd inv = do
  t <- getCurrentTime
  case cmd of
    ("add":kid:nm:qtd:xs) ->
      case reads qtd of
        [(q,"")] ->
          let ev = addItem t (ItemID kid) nm q (unwords xs) inv
          in execOp t ev inv
        _ -> putStrLn "qtd invalida" >> return inv

    ("remove":kid:qtd:_) ->
      case reads qtd of
        [(q,"")] ->
          execOp t (rmItem t (ItemID kid) q inv) inv
        _ -> putStrLn "qtd invalida" >> return inv

    ("update":kid:qtd:_) ->
      case reads qtd of
        [(q,"")] ->
          execOp t (updItem t (ItemID kid) q inv) inv
        _ -> putStrLn "qtd invalida" >> return inv

    ("list":_) -> listar inv >> return inv
    ("show":x:_) -> mostrar x inv >> return inv
    ("seed":_) -> popular
    ("report":_) -> relat >> return inv
    ("sair":_) -> putStrLn "encerrando..." >> return inv
    _ -> putStrLn "nao entendi" >> return inv

loop :: Inventario -> IO ()
loop inv = do
  putStr "inventario> "
  hFlush stdout
  l <- getLine
  let p = parse l
  if null p || head p == "sair"
    then do
      when (null p || head p == "sair") $ putStrLn "tchau"
      return ()
    else do
      inv2 <- processa p inv
      salvaInv inv2
      putStrLn ("salvei estado (sÃ³ por garantia). itens agora: " ++ show (M.size inv2))
      loop inv2

main :: IO ()
main = do
  putStrLn "Sistema de inventario"
  putStrLn "Carregando dados anteriores"
  logsLidos <- carregaLogs
  let invCarregado = rebuild logsLidos
  salvaInv invCarregado
  putStrLn ("Quantidade atual de itens: " ++ show (M.size invCarregado))
  putStrLn "Comandos:"
  putStrLn "add / remove / update / list / show / seed / report / sair"
  loop invCarregado

