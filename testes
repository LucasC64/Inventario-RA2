import Data.Map (Map)
import qualified Data.Map as Map
import Data.Time (UTCTime, getCurrentTime)
import System.IO (hFlush, stdout)
import System.Directory (doesFileExist)
import Control.Exception (catch, IOException
import Data.List (sortOn, group, maximumBy)
import Data.Ord (comparing
import Data.Char (isSpace)
import Data.Maybe (mapMaybe)
data Item = Item { itemID :: String, nome :: String, quantidade :: Int, categoria :: String }
  deriving (Show, Read, Eq)
type Inventario = Map String It

data Event = EAdd String String Int String | ERemove String Int | EUpdate String Int
  deriving (Show, Read, Eq)

data StatusLog = Sucesso | Falha String
  deriving (Show, Read, Eq)

data LogEntry = LogEntry { timestamp :: UTCTime, evento :: Event, detalhes :: String, status :: StatusLog }
  deriving (Show, Read, Eq)

type ResultadoOperacao = (Inventario, LogEntry

applyEvent :: Inventario -> Event -> Inventario
applyEvent inv (EAdd i n q c) = Map.insert i (Item i n q c) inv
applyEvent inv (ERemove i q) =
  case Map.lookup i inv of
    Nothing -> inv
    Just it ->
      let novo = quantidade it - q in if novo <= 0 then Map.delete i inv else Map.insert i (it { quantidade = novo }) inv
applyEvent inv (EUpdate i q) = Map.adjust (\it -> it { quantidade = q }) i inv

addItem :: UTCTime -> String -> String -> Int -> String -> Inventario -> Either String ResultadoOperacao
addItem t i n q c inv
  | Map.member i inv = Left "existe
  | q < 0 = Left "qneg"
  | otherwise = let ev = EAdd i n q c; inv' = applyEvent inv ev; l = LogEntry t ev ("+" ++ i) Sucesso in Right (inv', l)
removeItem :: UTCTime -> String -> Int -> Inventario -> Either String ResultadoOperacao
removeItem t i q inv
  | q <= 0 = Left "q<=0"
  | otherwise =
    case Map.lookup i inv of
      Nothing -> Left "nao-encontrado"
      Just it -> if quantidade it < q then Left "estoque" else let ev = ERemove i q;inv' = applyEvent inv ev; l = LogEntry t ev ("-" ++ i) Sucesso in Right (inv', l)
updateQty :: UTCTime -> String -> Int -> Inventario -> Either String ResultadoOperacao
updateQty t i q inv
  | q < 0 = Left "qneg"
  | otherwise =
    case Map.lookup i inv of
      Nothing -> Left "nao-encontrado
      Just _ -> let ev = EUpdate i q; inv' = applyEvent inv ev; l = LogEntry t ev ("=" ++ i) Sucesso in Right (inv', l)

reconstruirInventario :: [LogEntry] -> Inventario
reconstruirInventario logs = foldl applyEvent Map.empty [ evento x | x <- logs, case status x of Sucesso -> True; _ -> False ]

inventarioFile, logFile :: FilePath
inventarioFile = "Inventario.dat"
logFile = "Auditoria.log"

carregarInventario :: IO Inventario
carregarInventario = do
  ok <- doesFileExist inventarioFile
  if not ok then return Map.empty else do
    c <- readFile inventarioFile `catch` (\(_ :: IOException) -> return "fromList []")
    return (read c :: Inventario)

carregarLogs :: IO [LogEntry]
carregarLogs = do
  ok <- doesFileExist logFile
  if not ok then return [] else do
    c <- readFile logFile `catch` (\(_ :: IOException) -> return "")
    let ls = filter (not . all isSpace) (lines c)
        safe l = case reads l of [(v, "")] -> Just (v :: LogEntry); _ -> Nothing
    return (mapMaybe safe ls)

salvarInventario :: Inventario -> IO ()
salvarInventario inv = writeFile inventarioFile (show inv)

adicionarLog :: LogEntry -> IO ()
adicionarLog e = appendFile logFile (show e ++ "\n")

criarLogFalha :: UTCTime -> Event -> String -> LogEntry
criarLogFalha t ev msg = LogEntry t ev msg (Falha msg)

tokenize :: String -> [String]
tokenize = go . dropWhile isSpace where
  go "" = []
  go ('"':xs) = let (a, r) = span (/= '"') xs in a : go (dropWhile isSpace (drop 1 r))
  go s = let (tok, r) = break isSpace s in tok : go (dropWhile isSpace r)

processarComando :: [String] -> Inventario -> IO Inventario
processarComando parts inv = do
  t <- getCurrentTime
  case parts of
    ("add":i:n:qParts) -> let qStr = headDef "" qParts; name = headDef "" [n]; cat = unwords (tailDef [] qParts) in
      case reads qStr of
        [(q, "")] -> case addItem t i name q cat inv o
          Right (inv', l) -> adicionarLog l >> salvarInventario inv' >> putStrLn "feito" >> return inv'
          Left err -> adicionarLog (criarLogFalha t (EAdd i name (readDef 0 qStr) cat) err) >> putStrLn ("falha:" ++ err) >> return inv
        _ -> putStrLn "falha:q" >> return inv

    ("remove":i:qStr:_) ->
      case reads qStr of
        [(q, "")] -> case removeItem t i q inv of
          Right (inv', l) -> adicionarLog l >> salvarInventario inv' >> putStrLn "feito" >> return inv'
          Left err -> adicionarLog (criarLogFalha t (ERemove i (readDef 0 qStr)) err) >> putStrLn ("falha:" ++ err) >> return inv
        _ -> putStrLn "falha:q" >> return inv

    ("update":i:qStr:_) ->
      case reads qStr of
        [(q, "")] -> case updateQty t i q inv of
          Right (inv', l) -> adicionarLog l >> salvarInventario inv' >> putStrLn "feito" >> return inv'
          Left err -> adicionarLog (criarLogFalha t (EUpdate i (readDef 0 qStr)) err) >> putStrLn ("falha:" ++ err) >> return inv
        _ -> putStrLn "falha:q" >> return inv

    ("list":_) -> do
      let xs = sortOn itemID (Map.elems inv)
      mapM_ (\it -> putStrLn (itemID it ++ " | " ++ nome it ++ " : " ++ show (quantidade it))) xs
      return inv

    ("show":i:_) -> putStrLn (maybe "nao" show (Map.lookup i inv)) >> return inv

    ("seed":_) -> do
      t0 <- getCurrentTime
      ls <- carregarLogs
      let invR = reconstruirInventario ls
          novos = [ EAdd ("id" ++ show n) ("item" ++ show n) (n*2) "cat" | n <- [1..10], not (Map.member ("id" ++ show n) invR) ]
          logs = [ LogEntry t0 ev ("seed") Sucesso | ev <- novos ]
      mapM_ adicionarLog logs
      ls2 <- carregarLogs
      let inv2 = reconstruirInventario ls2
      salvarInventario inv2
      putStrLn "seed feito"
      return inv2

    ("report":_) -> do
      ls <- carregarLogs
      mapM_ putStrLn (historicoPorItem ls)
      mapM_ print (logsDeErro ls)
      putStrLn (itemMaisMovimentado ls)
      return inv

    ("sair":_) -> putStrLn "tchau" >> return inv
    _ -> putStrLn "?" >> return inv

headDef :: a -> [a] -> a
headDef d [] = d
headDef _ (x:_) = x

tailDef :: [a] -> [a] -> [a]
tailDef d [] = d
tailDef _ (_:xs) = xs

readDef :: Read a => a -> String -> 
readDef d s = case reads s of [(v,"")] -> v; _ -> d

historicoPorItem :: [LogEntry] -> [String]
historicoPorItem logs = let ids = concatMap extrai logs; groups = map (\g -> (head g, length g)) . group . sortOn id $ ids in map (\(i,n)-> i ++ ":" ++ show n) groups
  where extrai l = case evento l of EAdd i _ _ _ -> [i]; ERemove i _ -> [i]; EUpdate i _ -> [i]

logsDeErro :: [LogEntry] -> [LogEntry]
logsDeErro = filter (\l -> case status l of Falha _ -> True; _ -> False)

itemMaisMovimentado :: [LogEntry] -> String
itemMaisMovimentado logs = let ids = concatMap (\l -> case evento l of EAdd i _ _ _ -> [i]; ERemove i _ -> [i]; EUpdate i _ -> [i]) logs in if null ids then "nenhum" else let g = map (\grp -> (head grp, lth grp)) . group . sortOn id $ ids; (i,c) = maximumBy (comparing snd) g in i ++ "(" ++ show c 

