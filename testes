import Data.Map (Map)
import qualified Data.Map as Map
import Data.Time (UTCTime, getCurrentTime)
import System.IO (hFlush, stdout)
import System.Directory (doesFileExist)
import Control.Exception (catch, IOException)
import Data.List (sortOn, group, maximumBy)
import Data.Ord (comparing)
import Data.Char (isSpace)
import Data.Maybe (mapMaybe)

data Item = Item
  { itemID    :: String
  , nome      :: String
  , quantidade :: Int
  , categoria :: String
  } deriving (Show, Read, Eq)

type Inventario = Map String Item

data Event
  = EAdd String String Int String
  | ERemove String Int
  | EUpdate String Int
  deriving (Show, Read, Eq)

data StatusLog = Sucesso | Falha String
  deriving (Show, Read, Eq)

data LogEntry = LogEntry
  { timestamp :: UTCTime
  , evento    :: Event
  , detalhes  :: String
  , status    :: StatusLog
  } deriving (Show, Read, Eq)

type ResultadoOperacao = (Inventario, LogEntry)

applyEvent :: Inventario -> Event -> Inventario
applyEvent inv (EAdd id nm qtd cat) =
  let item = Item id nm qtd cat in Map.insert id item inv
applyEvent inv (ERemove id qtdRemover) =
  case Map.lookup id inv of
    Nothing -> inv
    Just it ->
      let nova = quantidade it - qtdRemover
      in if nova <= 0 then Map.delete id inv else Map.insert id (it { quantidade = nova }) inv
applyEvent inv (EUpdate id novaQtd) = Map.adjust (\it -> it { quantidade = novaQtd }) id inv

addItem :: UTCTime -> String -> String -> Int -> String -> Inventario -> Either String ResultadoOperacao
addItem tempo id nm qtd cat inv
  | Map.member id inv = Left "item ja existe"
  | qtd < 0           = Left "quantidade nao pode ser negativa"
  | otherwise =
      let ev = EAdd id nm qtd cat
          invNovo = applyEvent inv ev
          log = LogEntry tempo ev ("adicionou " ++ id) Sucesso
      in Right (invNovo, log)

removeItem :: UTCTime -> String -> Int -> Inventario -> Either String ResultadoOperacao
removeItem tempo id qtdRemover inv
  | qtdRemover <= 0 = Left "quantidade a remover deve ser positiva"
  | otherwise =
    case Map.lookup id inv of
      Nothing -> Left "item nao encontrado"
      Just it ->
        if quantidade it < qtdRemover
          then Left "estoque insuficiente"
          else
            let ev = ERemove id qtdRemover
                invNovo = applyEvent inv ev
                log = LogEntry tempo ev ("removeu " ++ show qtdRemover ++ " de " ++ id) Sucesso
            in Right (invNovo, log)

updateQty :: UTCTime -> String -> Int -> Inventario -> Either String ResultadoOperacao
updateQty tempo id novaQtd inv
  | novaQtd < 0 = Left "quantidade invalida"
  | otherwise =
    case Map.lookup id inv of
      Nothing -> Left "item nao existe"
      Just _ ->
        let ev = EUpdate id novaQtd
            invNovo = applyEvent inv ev
            log = LogEntry tempo ev ("atualizou " ++ id ++ " para " ++ show novaQtd) Sucesso
        in Right (invNovo, log)

reconstruirInventario :: [LogEntry] -> Inventario
reconstruirInventario logs =
  let eventosSucesso = [ evento l | l <- logs, case status l of Sucesso -> True; _ -> False ]
  in foldl applyEvent Map.empty eventosSucesso

inventarioFile :: FilePath
inventarioFile = "Inventario.dat"

logFile :: FilePath
logFile = "Auditoria.log"

carregarInventario :: IO Inventario
carregarInventario = do
  existe <- doesFileExist inventarioFile
  if not existe then return Map.empty
  else do
    conteudo <- readFile inventarioFile `catch` (\(_ :: IOException) -> return "fromList []")
    return (read conteudo :: Inventario)

carregarLogs :: IO [LogEntry]
carregarLogs = do
  existe <- doesFileExist logFile
  if not existe then return []
  else do
    conteudo <- readFile logFile `catch` (\(_ :: IOException) -> return "")
    let linhas = filter (not . all isSpace) (lines conteudo)
        safeRead l = case reads l of [(v, "")] -> Just (v :: LogEntry); _ -> Nothing
    return (mapMaybe safeRead linhas)

salvarInventario :: Inventario -> IO ()
salvarInventario inv = writeFile inventarioFile (show inv)

adicionarLog :: LogEntry -> IO ()
adicionarLog entry = appendFile logFile (show entry ++ "\n")

criarLogFalha :: UTCTime -> Event -> String -> LogEntry
criarLogFalha tempo ev msg = LogEntry tempo ev msg (Falha msg)

tokenize :: String -> [String]
tokenize = go . dropWhile isSpace
  where
    go "" = []
    go ('"':xs) = let (inside, rest) = span (/= '"') xs
                      rest' = drop 1 rest
                  in inside : go (dropWhile isSpace rest')
    go s = let (tok, rest) = break isSpace s in tok : go (dropWhile isSpace rest)

processarComando :: [String] -> Inventario -> IO Inventario
processarComando cmd inv = do
  tempo <- getCurrentTime
  case cmd of
    ("add":id:nm:qtdStr:catParts) ->
      let cat = unwords catParts in
      case reads qtdStr of
        [(qtd, "")] ->
          case addItem tempo id nm qtd cat inv of
            Right (invNovo, log) -> do
              adicionarLog log
              salvarInventario invNovo
              putStrLn "ok"
              return invNovo
            Left err -> do
              adicionarLog (criarLogFalha tempo (EAdd id nm (read qtdStr :: Int) cat) err)
              putStrLn ("erro: " ++ err)
              return inv
        _ -> putStrLn "quantidade invalida" >> return inv

    ("remove":id:qtdStr:_) ->
      case reads qtdStr of
        [(qtd, "")] ->
          case removeItem tempo id qtd inv of
            Right (invNovo, log) -> do
              adicionarLog log
              salvarInventario invNovo
              putStrLn "ok"
              return invNovo
            Left err -> do
              adicionarLog (criarLogFalha tempo (ERemove id (read qtdStr :: Int)) err)
              putStrLn ("erro: " ++ err)
              return inv
        _ -> putStrLn "quantidade invalida" >> return inv

    ("update":id:qtdStr:_) ->
      case reads qtdStr of
        [(qtd, "")] ->
          case updateQty tempo id qtd inv of
            Right (invNovo, log) -> do
              adicionarLog log
              salvarInventario invNovo
              putStrLn "ok"
              return invNovo
            Left err -> do
              adicionarLog (criarLogFalha tempo (EUpdate id (read qtdStr :: Int)) err)
              putStrLn ("erro: " ++ err)
              return inv
        _ -> putStrLn "quantidade invalida" >> return inv

    ("list":_) -> do
      let itens = Map.elems inv
          ordenados = sortOn itemID itens
      mapM_ (\i -> putStrLn (itemID i ++ " - " ++ nome i ++ " (" ++ show (quantidade i) ++ ")")) ordenados
      return inv

    ("show":id:_) -> do
      case Map.lookup id inv of
        Nothing -> putStrLn "item nao encontrado"
        Just it -> putStrLn (show it)
      return inv

    ("seed":_) -> do
      tempoNow <- getCurrentTime
      ls <- carregarLogs
      let invR = reconstruirInventario ls
          novos = [ ev | n <- [1..10]
                       , let idn = "id" ++ show n
                       , not (Map.member idn invR)
                       , let ev = EAdd idn ("item " ++ show n) (n*2) "categoria"
                 ]
          logs = [ LogEntry tempoNow ev ("seed add " ++ show ev) Sucesso | ev <- novos ]
      mapM_ adicionarLog logs
      ls2 <- carregarLogs
      let invFinal = reconstruirInventario ls2
      salvarInventario invFinal
      putStrLn "seed ok"
      return invFinal

    ("report":_) -> do
      logs <- carregarLogs
      mapM_ putStrLn (historicoPorItem logs)
      mapM_ print (logsDeErro logs)
      putStrLn (itemMaisMovimentado logs)
      return inv

    ("sair":_) -> do
      putStrLn "tchau"
      return inv

    _ -> do
      putStrLn "comando desconhecido"
      return inv

historicoPorItem :: [LogEntry] -> [String]
historicoPorItem logs =
  let ids = concatMap extraiID logs
      groups = map (\g -> (head g, length g)) . group . sortOn id $ ids
  in map (\(i,n) -> i ++ ": " ++ show n ++ " eventos") groups
  where
    extraiID l = case evento l of
      EAdd id _ _ _ -> [id]
      ERemove id _  -> [id]
      EUpdate id _  -> [id]

logsDeErro :: [LogEntry] -> [LogEntry]
logsDeErro = filter (\l -> case status l of Falha _ -> True; _ -> False)

itemMaisMovimentado :: [LogEntry] -> String
itemMaisMovimentado logs =
  let ids = concatMap extraiID logs
  in if null ids then "nenhum item"
     else let grouped = map (\g -> (head g, length g)) . group . sortOn id $ ids
              (idMax, cnt) = maximumBy (comparing snd) grouped
          in idMax ++ " (" ++ show cnt ++ " eventos)"
  where
    extraiID l = case evento l of
      EAdd id _ _ _ -> [id]
      ERemove id _  -> [id]
      EUpdate id _  -> [id]

loop :: Inventario -> IO ()
loop inv = do
  putStr "> "
  hFlush stdout
  linha <- getLine
  let cmd = tokenize linha
  if null cmd || head cmd == "sair"
    then putStrLn "encerrando..."
    else do
      invNovo <- processarComando cmd inv
      loop invNovo

main :: IO ()
main = do
  putStrLn "carregando sistema..."
  logs <- carregarLogs
  let invFromLog = reconstruirInventario logs
  _ <- carregarInventario
  let invAtual = invFromLog
  salvarInventario invAtual
  putStrLn ("itens: " ++ show (Map.size invAtual))
  putStrLn "comandos: add ID \"nome\" qtd \"categoria\" | remove ID qtd | update ID qtd | list | show ID | seed | report | sair"
  loop invAtual

